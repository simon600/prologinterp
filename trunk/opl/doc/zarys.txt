budowa interpretera:

-> interpreter pozwala tylko na podawanie celow (goals) i komend (commands)

Input to Interpretter
# goal    ::= predicate"."		-- input to intpereter at the "?-" prompt.
# command ::= ":-" predicate"." 	. Notice the periods and other punctuators!

interpreter pozwala na ladowanie programow prologowych tylko z pliku:
1) przez argumenty przy uruchomieniu w linii komend
2) przez komende "load(nazwa_pliku_niekoniecznie_z_rozszerzeniem)." i reload (analogicznie).

semantyka jest mniej wiecej taka, ze:
- load laduje cos do pamieci (dokleja do bazy danych prologa)
- reload zastepuje cos zaladowanego wczesniej w pamieci; jezeli to cos nie istnieje, to ma taka
sama semantyke jak load.

zastanawiam sie jeszcze nad komenda remove(nazwa_pliku), ktora wywali wszystko to z bazy danych, 
co znajduje sie w zadanym pliku. Moze byc przydatne, gdy ktos 2 razy zrobi load i bedzie chcial 
to wycofac bez utraty calej reszty bazy danych.

Slowem schemat jest nastepujacy: uruchamiamy interpreter z jakas baza (z pliku)
i pozwalamy na zadawanie pytan. 

HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH SKLADNIA HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH

cztery rodzaje znakow:

++++++++++++++++++++++     1) litery, cyfry, _ : +++++++++++++++++++++++++++++++++++++++++++++++++++++
   a-z, A-Z, 0-9, _

++++++++++++++++++++++     2) znaki specjalne    +++++++++++++++++++++++++++++++++++++++++++++++++++++
# & * + - . / : ;
? @ / ~  $   < = >

zastosowanie: http://www.ifcomputer.co.jp/jp/manuals5.2/refman/node481.html

++++++++++++++++++++++     3) znaki charakterystyczne dla prologa       ++++++++++++++++++++++++++++++

, ! ( ) { } [ ] — '  %

++++++++++++++++++++++     4) separatory    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Blank, Tab character, New line character


HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH ELEMENTY LEKSYKALNE HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH


++++++++++++++++++++++ 		atomy		++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ciagi znakow zaczynajace sie od malej litery i skladajace sie z liczb, liter lub _
    ciagi znakow skladajace sie ze znakow specjalnych  (?-)
    lanuchy znakow zamkniete w apostrofach. (wtedy backslash ma magiczne znaczenie)
    [] (lista pusta)

++++++++++++++++++++++ 		zmienne		++++++++++++++++++++++++++++++++++++++++++++++++++++++

    nazwy zaczynajace sie od duzej litery lub podkreslenia

_ - wildcard


++++++++++++++++++++++ 		liczby calkowite   +++++++++++++++++++++++++++++++++++++++++++++++++++

	(w roznych notacjach)
	(proponuje ograniczyc sie do dziesietnej)

	byc moze poprzedzone znakiem minus


++++++++++++++++++++++ 		liczby zmiennoprzecinkowe	++++++++++++++++++++++++++++++++++++++

	
	ciagi cyfr, zawierajace kropke lub wykladnik, byc moze poprzedzone znakiem - 


[][l] [t] {[ - {] {{ N1.N2  {{   N1  N1.N2  } {{   E  e  } {[  {{   +  -  } } exponent  } } }



++++++++++++++++++++++ 		Prolog-specific characters	++++++++++++++++++++++++++++++++++++++


++++++++++++++++++++++		nawiasy		++++++++++++++++++++++++++++++++++++++++++++++++++++++

( ), [ ] oznaczaja struktury lub listy

++++++++++++++++++++++		Separators 	++++++++++++++++++++++++++++++++++++++++++++++++++++++

  puste znaki -> 	' ' 
  znak tabulacji -> 	'\t' 
  znak nowej linii -> 	'\n'
  
  komentarze:
 	komentarze konczace sie nowa linia: %
  	komentarze zmiennej dlugosci: /* */

	w naszej implementacji zakladamy, ze komentarze nie moga sie zagniezdzac.
	kiedys moze to zmienimy

++++++++++++++++++++++          stringi         ++++++++++++++++++++++++++++++++++++++++++++++++++++++

w ' ' lub w " "

\'\n' powoduje olanie nowej linii


HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH TERMY HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH

term ::= constant | variable | structure | (term)

structure = functor (argument, ..., argument) | expression | non-empty-list
functor = atom

expression = argument1 infixoperator argument2 | prefixoperator argument1  | argument1 postfixoperator
argument = term

constant ::= atom | number


%% Using op/3, further operators can be declared and canceled again. op/3 can also be used to cancel 
%% any built-in operator declaration.
%% infix_operator is an operator declared with xfx, xfy or yfx.
%% prefix_operator is an operator declared with fx or fy.
%% postfix_operator is an operator declared with xf or yf. 
%%
%%  fy or xfy -> right-associative, 
%%  yf or yfx -> left-associative 



list ::= empty_list | non-empty-list
empty-list ::= []


Head ::= term
Tail ::= list

non-empty-list =
	  .( Head, Tail )
	| [ Element {, Element}* ] 


expression ::=  

%% atoms (except for operators), numbers, variables, normal structures and lists have the precedence 0,
%% terms enclosed in parentheses - ( term ) - have the precedence 0,
%% expressions not enclosed in parentheses take the precedence of their associated operator. 

built-in operators:

http://www.ifcomputer.co.jp/jp/manuals5.2/refman/node507.html

#################################################################################################################



