% Wersja October 18, 06:09:13 PM  
\documentclass[11pt,leqno]{article}
\usepackage[cp1250]{inputenc}  % Polskie literki...
\usepackage{polski}            % Polskie tytu³y, data, bibliografia, itp.
\usepackage{a4wide}            % Szersza strona...

\usepackage{amsmath,amssymb}   % Do³¹czamy zestaw ró¿nych przydatnych znaczków...
\usepackage{bbm}               % \mathbbm{N} - zbior liczb naturalnych
\usepackage{amsthm}
\usepackage{bnf}

\usepackage[dvipdfm,colorlinks=true]{hyperref}          % aby móc umieszczaæ linki w PDFie

\title{\LARGE \textbf{Interpreter jêzyka Prolog}\\
                    zaimplementowany w jêzyku OCaml}
\author{Karol Stosiek\thanks{\textit{E-mail}: \texttt{karol.stosiek@gmail.com}}%
	\and Szymon Fogiel\thanks{\textit{E-mail}: \texttt{szymek.fogiel@gmail.com}}}
\date{Wroc³aw, \today}



\begin{document}
\maketitle                % Utworzenie tytu³u.
\thispagestyle{empty}     % Nie numerujemy pierwszej strony.
\newpage

\tableofcontents          % Spis treœci
\newpage

\section{Wstêp}
\section{Ogólny zarys}
	Napisany przez nas interpreter sk³adni¹ odpowiada ogólnie przyjêtej sk³adni Prologa; staraliœmy siê tak¿e zachowaæ
	semantykê operatorów. W obecnej implementacji interpreter zawiera obs³ugê predykatów; nie mo¿na korzystaæ z dyrektyw
	ani gramatyk bezkontekstowych. 

	\subsection{£adowanie bazy wiedzy}
	
	Interpreter przyjmuje na wejœciu bazy wiedzy, wed³ug których bêdzie przeprowadza³ wnioskowanie.
	Ka¿da baza wiedzy jest reprezentowana przez osobny plik, którego nazwa jest podawana jako argument 
	wywo³ania interpretera. 
	
	Tym samym, uruchomienie intepretera z bazami zawartymi w plikach db1.opl, db2.opl, db3.opl bêdzie wygl¹da³o
	nastêpuj¹co:
	
	\begin{center}
		\begin{verbatim} opl.exe db1.opl db2.opl db3.opl \end{verbatim}
	\end{center}

	Interpreter wczytuje bazy wiedzy w kolejnoœci podanej przy wywo³aniu i do³¹cza listê predykatów zawartych 
	w danej bazie do listy dotychczas wczytanych predykatów, tworz¹c tym samym jednolit¹ bazê wiedzy.
	
	\subsection{Formu³owanie zapytañ}
	
	Po wczytaniu baz wiedzy, interpreter przechodzi do trybu zapytañ. Szczegó³owa sk³adnia zapytañ znajduje siê
	w dodatku B. \ref{Appendix:grammar}; symbolem startowym gramatyki w tym wypadku jest \textit{<query>}.		
	
\section{System wnioskowania}
	System wnioskowania dzia³a w doœæ prosty sposób. Interpreter zapytany o jak¹œ relacjê zaczyna przegl¹danie po kolei bazy wiedzy. Stara siê zunifikowaæ zapytanie z faktem lub nastêpnikiem implikacji w bazie danych.

	Jeœli zapytanie zosta³o zunifikowane z faktem to zwrócona zostaje odpowiedŸ („Yes”) oraz podstawienie które zosta³o u¿yte do unifikacji.

	Jeœli zapytanie zosta³o zunifikowane z nastêpnikiem implikacji to program stara siê udowodniæ poprzednik implikacji, korzystaj¹c ju¿ z podstawienia które zosta³o wygenerowane przy unifikacji z nastêpnikiem. Proces jest rekurencyjny, tzn. podtermy s¹ interpretowane w taki sam sposób jak termy do których nale¿¹.
	
	W trakcie wnioskowania zapamiêtywane s¹ inne mo¿liwe œcie¿ki dowodu. Po zwróceniu wyniku u¿ytkownik jest pytany czy chce szukaæ innych rozwi¹zañ.

	W wypadku natrafienia na operator odciêcia program nie zapamiêtuje dalszych œcie¿ek obliczeñ, w ten sposób mo¿na przerwaæ obliczenia, które mog¹ trwaæ w nieskoñczonoœæ (do przepe³nienia stosu).

	
\section{Budowa interpretera}
	\subsection{Podzia³ logiczny}
	\subsection{Podzia³ fizyczny}
	
\section{Dodatek A - operatory}
	\begin{description}
	\item \textbf{Operatory infixowe: }
		\begin{center}
		\small
		\begin{tabular}{|c|l|}\hline
		\multicolumn{1}{|c|}{Operator} & \multicolumn{1}{|c|}{Dzia³anie}\\\hline\hline

		= & unifikacja termów, unifikuje termy jeœli to mo¿liwe i zwraca podstawienie\\\hline
		$\backslash$= & odpowiada na pytanie, czy termy siê nie unifikuj¹\\\hline
		is & ewaluuje praw¹ stronê i podstawia pod zmienn¹ z lewej strony\\\hline
		== & sprawdza czy termy s¹ identyczne\\\hline
		$\backslash$== & sprawdza czy termy nie s¹ identyczne\\\hline
		=:= & sprawdza czy wyra¿enia arytmetyczne po obu stronach daj¹ ten sam wynik\\\hline
		=$\backslash$= & sprawdza czy wyra¿enia arytmetyczne po obu stronach daj¹ ró¿ny wynik\\\hline
		$<$ & sprawdza czy wyra¿enie arytmetyczne po lewej stronie daje mniejszy wynik\\\hline
		$>$ & sprawdza czy wyra¿enie arytmetyczne po lewej stronie daje wiêkszy wynik\\\hline
		$<$= & sprawdza czy wyra¿enie arytmetyczne po lewej stronie daje mniejszy lub równy wynik\\\hline
		$>$= & sprawdza czy wyra¿enie arytmetyczne po lewej stronie daje wiêkszy lub równy wynik\\\hline
		+ & sumowanie wyra¿eñ arytmetycznych\\\hline
		- & odejmowanie wyra¿eñ arytmetycznych\\\hline
		* & mno¿enie wyra¿eñ arytmetycznych\\\hline
		/ & dzielenie wyra¿eñ arytmetycznych\\\hline
		// & dzielenie ca³kowite wyra¿eñ arytmetycznych\\\hline
		, & koniunkcja\\\hline
		; & alternatywa\\\hline
		\end{tabular}
		\end{center}	


\item \textbf{Operatory bezargumentowe: }
		\begin{center}
		\small
		\begin{tabular}{|c|l|}\hline
		\multicolumn{1}{|c|}{Operator} & \multicolumn{1}{|c|}{Dzia³anie}\\\hline\hline

		! & obciêcie, jest zawsze prawdziwy i powoduje, ¿e nie s¹ obliczane alternatywne\\
		  & œcie¿ki wnioskowania\\\hline
		rel($a_1,a_2,...,a_k$) & zapytanie do bazy danych o prawdziwoœæ relacji "rel" na\\
		& argumentach $a_1,a_2,...,a_k$\\\hline
		\end{tabular}
		\end{center}	


	\end{description}

\section{Dodatek B - gramatyka}{\label{Appendix:grammar}}
	
	\begin{grammar}
		[(colon){$\rightarrow$}]
		[(semicolon)$|$]
		[(comma){}]
		[(period){\\}]
		[(quote){}{}]
		[(nonterminal){$\langle$}{$\rangle$}]
		
		<sentence list> : <clause> "\verb'.'" <sentence list> ; <clause> "\verb'..'" .		
		<query> : <clause> "\verb'.'" .
		<clause> : <head> "\verb':-'" <body> ; <head> .	
		<head> : <goal> .		
		<body> : <goal> "\verb';'" <body> ; <goal> "\verb','" <body> ; <goal> .		
		<goal> : <term>.
		
		<term>  : <term0> . 		
		<term0> : <term1> . 		
		<term1> : <term2> .		
		<term2> : <term2> "\verb'->'" <term3> ; <term2> "\verb'->'" <term3> "\verb':'" <term3> ; <term3> .		
		<term3> : <term4> .	
		<term4> : "\verb'not'" <term5> ; <term5> \\		
		<term5> : <term5> "\verb'=:='" <term5>	\\
				  ; <term5> "\verb'=='" <term5> \\
		    	; <term5> "\verb'='" <term5> \\
		    	; <term5> "\verb'\='" <term5> \\
		    	; <term5> "\verb'=='" <term5> \\
		    	; <term5> "\verb'\=='" <term5>\\
		    	; <term5> "\verb'is'" <term5>\\
		    	; <term5> "\verb'=..'" <term5>\\
		    	; <term5> "\verb'>='" <term5>\\
		    	; <term5> "\verb'<='" <term5> \\
		    	; <term5> "\verb'<'" <term5>\\
		    	; <term5> "\verb'>'" <term5>\\
		    	; <term5> "\verb'@='" <term5>\\
		    	; <term5> "\verb'@\='" <term5>\\
		    	; <term5> "\verb'@<'" <term5>\\
		    	; <term5> "\verb'@>'" <term5>\\
		    	; <term5> "\verb'@>='" <term5>\\
		    	; <term5> "\verb'@=<'" <term5>\\
		    	; <term6> .		    	
		<term6> : <term6> "\verb'::'" <term6> ; <term7> .	
		<term7> : <term7> "\verb'+'" <term7> ; <term7> "\verb'-'" <term7> ; <term8> .	
		<term8> : <term8> "\verb'rem'" <term8>\\
		    	; <term8> "\verb'mod'" <term8>\\
		    	; <term8> "\verb'divs'" <term8>\\
		    	; <term8> "\verb'mods'" <term8>\\
		    	; <term8> "\verb'divu'" <term8>\\
		    	; <term8> "\verb'modu'" <term8>\\
		    	; <term8> "\verb'/'" <term8>\\
		    	; <term8> "\verb'//'" <term8>\\
		    	; <term8> "\verb'*'" <term8>\\
		    	; <term8> "\verb'>>'" <term8>\\
		   		; <term8> "\verb'<<'" <term8>\\
		   		; <term8> "\verb'**'" <term8>\\
		    	; "\verb'^'" <term8>\\
		    	; <term8> "\verb'/\'" <term8>\\
		    	; <term8> "\verb'\/'" <term8>\\
		    	; <term8> "\verb'\\'" <term8>\\
		    	; <term9> .	    	
		<term9> : "\verb'!'" ; <term10> . 		
		<term10> : <term list> ; "\verb'('" <term0> "\verb')'" 
					 ; <string> ; <variable> ; <constant> \\
		    	 ; <functor name> "\verb'('" <arguments> "\verb')'" .	    	 
		
		<term list> : "\verb'['" "\verb']'" ; "\verb'['" <arguments> "\verb']'" ; "\verb'['" <arguments> "\verb'|'" <arguments> "\verb']'" .
		<functor name> : <name> .	
		<arguments> : <term0> "\verb','" <arguments> ; <term0> .		
		<constant> : <name> ; <number> .	
		<name> : <name> .		
		<number> : <float number> ; <integer number> .
		
		<capital> : "$[\verb'A'-\verb'Z']$" .
		<small> : "$[\verb'a'-\verb'z']$"  .       
		<digit> : "$[\verb'0'-\verb'9']$"   .      
		<underline> : "\verb'_'" .    
		<alpha> : <capital> ; <small> ; <digit> ; <underline> .       
		<word> : <small> <alpha>"$*$".                         
		<quoted name> : "\verb"'"" ; 
		"$[\verb'^' \verb"'" ]+ $" ; 
		"\verb"'"" .            
		<symbol> : "\verb'+'" ; "\verb'-'" ; "\verb'*'" ; "\verb'/'"  
			 				 "\verb'\'" ; "\verb'^'" ; "\verb'<'" ; "\verb'>'" 
							 "\verb'='" ; "\verb'~'" ; "\verb':'" ;	"\verb'?'" 		
							 "\verb'@'" ; "\verb'#'" ; "\verb'$'" ;	"\verb'&'" .		
		<solo char> : "\verb'!': ; "$\verb';'$" ; "$\verb'.'$" ; "\verb'['" ; 
									"\verb']'" ; "\verb'('" ; "\verb')'" ; "\verb','" ; "\verb'|'.              
		
		<name> : <quoted name> ; <word> ; <symbol>"$+$" ; <solo char>.   
		<variable> : "$($" <capital> ; <underline> "$)$" <alpha> "$*$" .           
	  <string> :  <any printable character in double qoutes> .                  
		
		<sign> : "\verb'+'" ; "\verb'-'"  .                                 
		<exp> : "$(\verb'e'$" ; "\verb'E'$)$" <sign>"\verb'?'" digit"\verb'+'" .                 
		<simple float> : <digit>"$*$ \verb'.'" <digit>"$+$"  .                 
		<simple integer> : <digit>"$+$" .                      
		<float number> : <sign>"$?$" <simple float> <exp>"$?$"   .            
		<integer number> : <sign>"$?$" <simple integer> <exp>"$?$"  .  
		 
\end{grammar}


\section{Dodatek C - napotkane problemy}

\end{document}